Laboratory: Spell-checking Hawaiian

tr -c 'A-Za-z' '[\n*]'
This command grasp the words of English letter in the webpage
by splitting them using characters other than English letters,
replacing those with newlines, and put the words and newlines
into a list and output it

tr -cs 'A-Za-z' '[\n*]'
This command basically does the same thing as the previous one
except that it removes the seccessive multiple occurence of
newlines

tr -cs 'A-Za-z' '[\n*]' | sort
This command basically does the same thing as the previous one
except that it sorts the output list based on ASCII order

tr -cs 'A-Za-z' '[\n*]' | sort -u
This command basically does the same thing as the previous one
except that it removes the repetition of words

tr -cs 'A-Za-z' '[\n*]' | sort -u | comm - words
This command basically does the same thing as the previous one
except that it make a comparison from the output to the words
file, which is a English words dictionary like file in the
system, and instead output the original list, it output three
columns represents the lines unique to the output list, unique
to the dictionary and occurring in both outputs

tr -cs 'A-Za-z' '[\n*]' | sort -u | comm -23 - words
This command basically does the same thing as the previous one
except that it only shows the column with items unique to the
original list

the buildwords script:

#! /bin/bash

sort_file ( ) {
    tr -cs "pkmnwlhaeiou\'" '[\n*]' $1 |
    tr [:upper:] [:lower:] |
    sort -u
}

get_dict ( ) {
    curl -Os "http://mauimapp.com/moolelo/hwnwdseng.htm"
    grep -E '((<td>).+(</td>))' hwnwdseng.htm |
    sed '1~2d' |
    sed 's/<td>//g' |
    sed 's/<\/td>//g' |
    sed 's/<u>//g' |
    sed 's/<\/u>//g' |
    sed 's/, /\n/g' |
    sed 's/ /\n/g' |
    tr -d "^( +)" |
    sed "s/\`/\'/g" |
    tr [:upper:] [:lower:] |
    grep -v '?' |
    grep -v '-' |
    # should I remove '-' also?
    sort -u > hwords
    rm hwnwdseng.htm
}

get_dict
sort_file $1 | comm -23 - hwords
rm hwords

This script basically does the following things:
1. It gets the webpage containing the Hawaiian words and
transform it into a temporary file named hwords, which
is the Hawaiian dictionary we will need later
2. It sort the source file that will be checked later by
grasping all the words containing only Hawaiian letters,
putting them in a list, and use sort command
3. It compares the list and the hwords file, and output a
column with words that is in the list but not in the Hawaiian
dictionary hwords
4. remove the temporary file hwords


Running the script on the assignment webpage, we have
the following results:
On the webpage, the misspelled English words but correct
as Hawaiian are:
halau
lau
wiki
On the webpage, the misspelled Hawaiian words but correct
as English are:
a
ail
ain
ake
al
ale
alen
all
amine
amp
ample
an
aph
aul
awk
ea
ee
el
em
emp
en
ep
epa
h
ha
han
hap
he
hei
hell
hem
hen
hi
hin
ho
how
howe
ia
ie
ile
imp
in
ion
iou
k
keep
kin
l
lan
le
lea
li
like
line
link
ll
ln
lo
lowe
m
mail
man
me
men
mi
ml
mo
mp
n
name
ne
nee
no
non
nu
num
o
om
on
one
op
ope
open
owe
own
p
pe
pell
people
plea
pu
u
ui
ula
ule
ume
ump
un
uni
w
wa
wan
we
wh
wha
who
wi
wo

Homework: Find duplicate files

the sameln script:

#! /bin/bash

FILE_LIST=`find "$1" -maxdepth 1 -type f -printf "%f\n" | sort`
D=$1

check_diff() {
    result=`diff "$D/$1" "$D/$2"`
    if [ -n "$result" ]; then
	return 1
    else
	return 0
    fi
}

length=`echo "$FILE_LIST" | wc -l`
i=1
while [ $i -le $length ]
do
    sample=`echo "$FILE_LIST" | head -n "$i" | tail -n 1`
    SAME_FILE_LIST=""
    j=1
    while [ $j -le $length ]
    do
	candidate=`echo "$FILE_LIST" | head -n "$j" | tail -n 1`
	check_diff "$sample" "$candidate"
	if [ $? -eq 0 ]
	then
	    if [ -n "$SAME_FILE_LIST" ]; then
		SAME_FILE_LIST="$SAME_FILE_LIST"$'\n'"$candidate"
	    else
		SAME_FILE_LIST="$candidate"
	    fi
	fi
	let j=j+1
    done
    DOT_LIST=""
    REG_LIST=""
    same_length=`echo "$SAME_FILE_LIST" | wc -l`
    k=1
    while [ $k -le $same_length ]
    do
	identical=`echo "$SAME_FILE_LIST" | head -n "$k" | tail -n 1`
	dot_check=`echo "$identical" | grep "^\."`
	if [ -n "$dot_check" ]; then
	    if [ -n "$DOT_LIST" ]; then		
		DOT_LIST="$DOT_LIST"$'\n'"$identical"
	    else
		DOT_LIST="$identical"
	    fi
	else
	    if [ -n "$REG_LIST" ]; then
		REG_LIST="$REG_LIST"$'\n'"$identical"
	    else
		REG_LIST="$identical"
	    fi
	fi
	let k=k+1
    done
    DOT_LIST=`echo "$DOT_LIST" | sort`
    REG_LIST=`echo "$REG_LIST" | sort`
    reserve=""
    dot_flag=0
    if [ -n "$DOT_LIST" ]; then
	reserve=`echo "$DOT_LIST" | head -n 1`
	dot_flag=1
    else
	reserve=`echo "$REG_LIST" | head -n 1`
    fi
    dash_check=`echo "$reserve" | grep "^\-"`
    reserve_tmp=$(printf '%q\n' "$reserve" | sed "s/\./\\\./g")
    if [ -n "$dash_check" ]; then
	reserve_tmp=$(echo "$reserve_tmp" | sed "s/\-/\\\-/g")
    fi
    DELETE_FILE_LIST=`echo "$SAME_FILE_LIST" | grep -xv "$reserve_tmp"`
    delete_length=`echo "$DELETE_FILE_LIST" | wc -l`
    l=1
    while [ $l -le $delete_length ]
    do
	delete=`echo "$DELETE_FILE_LIST" | head -n "$l" | tail -n 1`
	rm "$D/$delete"
	ln "$D/$reserve" "$D/$delete"
	let l=l+1
    done
    let i=i+1
done

    
This script basically does the following things:
1. It gets all the files' name that is directly under the
given directory and put them into a list
2. It loop through the file list for each file as a source,
and then run a nested loop on the file list, for each file
as a candidate. It then compares the two files using diff.
If two files are different in content, put the candidate's
name in a list called SAME_FILE_LIST. If not, continue.
3. Inside the outer loop and after the SAME_FILE_LIST is
generated, it checks if the file name in the list contains
a dot at the beginning. Based on that it split the file names
in two seperate lists. It then sorts each list. It will output
the first item in the DOT_LIST to be the reserved file. If
DOT_LIST is empty, pick the first item in REG_LIST.
4. Using grep, it delete the reserved file's name inside the
SAME_FILE_LIST, making it a new list called DELETE_FILE_LIST.
Then, it will make every file whose name appears in this list
a hard link to the file named reserved file by first deleting
it and then create the hard link with the same name.
5. It will repeat the 2nd~4th step until the outer loop ends.